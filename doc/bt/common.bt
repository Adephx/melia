//--------------------------------------
//--- 010 Editor v8.0 Binary Template
//
//      File: common.bt
//   Authors: exec, celophi
//   Version: i170175
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//   - i10671:  APPEARANCE_PC.i6~i7 were added
//   - i11025:  APPEARANCE_PC.teamId was added
//   - i11025:  MONSTER.s1~s2 were removed
//   - i11025:  EquipSlotCount increased to 21
//   - i170175: EquipSlotCount increased to 22 (lens)
//   - i170175: APPEARANCE_PC.i9 was added
//   - i171032: APPEARANCE_PC.i9 was removed
//   - i171032: EquipSlotCount increased to 23 (wings)
//------------------------------------------------

const int EquipSlotCount = 23;

// Length-prefixed string
typedef struct
{
    short length;
    if(length > 0)
        char text[length];
}
lpString <read=lpStringRead>;

string lpStringRead(lpString &v)
{
    if(v.length > 0)
        return v.text;
    else
        return "";
}

// Key:Value type with two length-prefixed strings
typedef struct
{
    lpString key;
    lpString value;
}
msgParameter <read=msgParameterRead>;

string msgParameterRead(msgParameter &v)
{
    return v.key.text + " : " + v.value.text;
}

// Position in 3D space
typedef struct
{
    float x;
    float y;
    float z;
}
position <read=positionRead>;

string positionRead(position &v)
{
    local string result;
    SPrintf(result, "X: %f, Y: %f, Z: %f", v.x, v.y, v.z);
    return result;
}

// 2D direction
typedef struct
{
    float x;
    float y;
}
direction <read=directionRead>;

string directionRead(direction &v)
{
    local string result;
    SPrintf(result, "X: %f, Y: %f", v.x, v.y);
    return result;
}

// Map data used in revealing
typedef struct
{
    int mapId;
    byte data[128];
}
mapRevealData <read=mapRevealDataRead>;

string mapRevealDataRead(mapRevealData &v)
{
    local string result;
    SPrintf(result, "%d", v.mapId);
    return result;
}

typedef struct
{
    short size;
    if(size > 0)
        byte properties[size]; // todo, short:val list
}
ItemProperties;

typedef struct
{
    char name[65];
    char teamName[64];
    byte bin[7];
    int64 accountId;
    short stance;
    short s1;
    short job;
    byte gender;
    byte b1;
    int level;
    int equipIds[EquipSlotCount];
    int i6;
    int i7;
    short hair;

    // Up until i171032 we had these as "pose" and "team id",
    // but they actually contain the visible hats, so we either
    // had them wrong, or they changed. This was first noticed in
    // i170175.
    //short pose;
    //int teamId;
    byte b2;
    byte hat1Visible;
    byte hat2Visible;
    byte hat3Visible;
}
APPEARANCE_PC;

typedef struct {
    int handle;
    int i1;
    APPEARANCE_PC appearancePc;
    position pos;
    int currentExp;
    int maxExp;
    int totalExp;
    int64 characterId;
    int64 socialInfoId;
    int hp;
    int maxHp;
    short sp;
    short maxSP;
    int stamina;
    int maxStamina;
    short shield;
    short maxShield;
} COMMANDER;

typedef struct
{
    int monsterId;
    int i1;
    int maxHp;

    //short s1;
    //short s2;

    int level;
    float sdr;
    byte b1;
    byte bin2[3];
}
MONSTER;

typedef struct
{
    APPEARANCE_PC appearancePc;
    int64 characterId;
    byte index;
    byte b1;

    short mapId;
    short channel;
    short s1;
    int i1;
    int i2;   // max xp?
    int i3;    

    float x;
    float y;
    float z;
    float d1; // direction?
    float d2; // direction?

    float x2;
    float y2;
    float z2;
    float d12;
    float d22;

    int i5;

} APPEARANCE_BARRACK_PC;

typedef struct
{
    ubyte b1;
    ubyte b2;
    ubyte b3;
    ubyte b4;
}
IP <read=IPRead>;

string IPRead(IP &v)
{
    local string result;
    SPrintf(result, "%d.%d.%d.%d", v.b1, v.b2, v.b3, v.b4);
    return result;
}

typedef struct
{
    int id;
    short propertiesSize;
    short b1;
    int64 worldId;
    int amount;
    int price;
    int index;
    int i1;
    if (propertiesSize > 0)
        byte properties[propertiesSize];
}
Item;

string ItemRead(Item &v)
{
    local string result;
    SPrintf(result, "%d", v.id);
    return result;
}

typedef struct
{
    int id;
    short propertiesSize;
    short b1;
    int64 worldId;
    byte slot;
    byte bin1[3];
    int i1;
    if (propertiesSize > 0)
        byte properties[propertiesSize];
}
EquipItem;

string EquipItemRead(EquipItem &v)
{
    local string result;
    SPrintf(result, "%d : %d", v.slot, v.id);
    return result;
}

typedef struct
{
    int index;
    char msg[128];  // This may also be a class ID of an emoji.
    int pose;
} CHAT_MACRO_INFO;

typedef struct
{
    ushort header;
    short size;
    byte data[size];
}
compressedData <read=compressedDataRead>;

string compressedDataRead(compressedData &v)
{
    local string result;
    SPrintf(result, "Compressed data (%d)", v.size);
    return result;
}

byte checkCompression()
{
    if (ReadUShort() == 0xFA8D)
    {
        compressedData data;
        return 1;
    }
    else
    {
        short noCompression;
        return false;
    }
}

typedef struct
{
    int64 skillObjectId;
    int id;
    short propertiesSize;
    byte bin1[2];
    int i1;
    short s1;
    byte bin2[2];
    byte properties[propertiesSize];
}
Skill <read=readSkill>;

string readSkill(Skill &v)
{
    local string result;
    SPrintf(result, "%d", v.id);
    return result;
}

typedef struct
{
    int64 l1;
    int id;
    short s1; // properties?
    short s2;
}
Ability <read=readAbility>;

string readAbility(Ability &v)
{
    local string result;
    SPrintf(result, "%d", v.id);
    return result;
}

typedef struct
{
    int i1;
    int itemId;
    int amount;
    int received; // bool?
}
MessageItem;

typedef struct
{
    lpString sender;
    lpString title;
    lpString text;
    FILETIME date1;
    FILETIME expiration;
    FILETIME date2;
    int64 id;
    byte b1;
    short s1;
    short read; // ?
    short s3;
    int itemCount;
    if (itemCount != 0)
        MessageItem items[itemCount] <optimize=false>;
}
Message;
